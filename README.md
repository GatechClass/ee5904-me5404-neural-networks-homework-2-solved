# ee5904-me5404-neural-networks-homework-2-solved
**TO GET THIS SOLUTION VISIT:** [EE5904_ME5404-Neural Networks: Homework 2 Solved](https://mantutor.com/product/ee5904_me5404-neural-networks-homework-2-solved/)


---

**For Custom/Order Solutions:** **Email:** mantutorcodes@gmail.com  

*We deliver quick, professional, and affordable assignment help.*

---

<h2>Description</h2>



<div class="kk-star-ratings kksr-auto kksr-align-center kksr-valign-top" data-payload="{&quot;align&quot;:&quot;center&quot;,&quot;id&quot;:&quot;72851&quot;,&quot;slug&quot;:&quot;default&quot;,&quot;valign&quot;:&quot;top&quot;,&quot;ignore&quot;:&quot;&quot;,&quot;reference&quot;:&quot;auto&quot;,&quot;class&quot;:&quot;&quot;,&quot;count&quot;:&quot;1&quot;,&quot;legendonly&quot;:&quot;&quot;,&quot;readonly&quot;:&quot;&quot;,&quot;score&quot;:&quot;5&quot;,&quot;starsonly&quot;:&quot;&quot;,&quot;best&quot;:&quot;5&quot;,&quot;gap&quot;:&quot;4&quot;,&quot;greet&quot;:&quot;Rate this product&quot;,&quot;legend&quot;:&quot;5\/5 - (1 vote)&quot;,&quot;size&quot;:&quot;24&quot;,&quot;title&quot;:&quot;EE5904_ME5404-Neural Networks: Homework 2 Solved&quot;,&quot;width&quot;:&quot;138&quot;,&quot;_legend&quot;:&quot;{score}\/{best} - ({count} {votes})&quot;,&quot;font_factor&quot;:&quot;1.25&quot;}">

<div class="kksr-stars">

<div class="kksr-stars-inactive">
            <div class="kksr-star" data-star="1" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="2" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="3" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="4" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="5" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
    </div>

<div class="kksr-stars-active" style="width: 138px;">
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
    </div>
</div>


<div class="kksr-legend" style="font-size: 19.2px;">
            5/5 - (1 vote)    </div>
    </div>
<strong>Q1</strong>. <strong>Rosenbrock’s Valley Problem</strong> <strong>&nbsp;</strong>Consider the Rosenbrock’s Valley function:which has a global minimum at (x, y) = (1,1) where f(x, y) = 0. Now suppose the starting point is randomly initialized in the open interval (0, 1) for x and y, find the global minimum using:

a). Steepest (Gradient) descent method

<sup>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </sup><em>w</em>(<em>k </em>1)  <em>w</em>(<em>k</em>) <em>g</em>(<em>k</em>)

with learning rate η = 0.001. Record the number of iterations when f(x, y) converges to (or very close to) 0 and plot out the trajectory of (x, y) in the 2-dimensional space. Also plot out the function value as it approaches the global minimum. What would happen if a larger learning rate, say η = 0.5, is used?

b). Newton’s method (as discussed on page 13 in the slides of lecture Four)

<em>w</em>(<em>n</em>) <em>H</em><sup></sup><sup>1</sup>(<em>n</em>)<em>g</em>(<em>n</em>)

Record the number of iterations when f(x, y) converges to (or very close to) 0 and plot out the trajectory of (x, y) in the 2-dimensional space. Also plot out the function value as it approaches the global minimum.

<h1>Q2. Function Approximation</h1>
Consider using MLP to approximate the following function:&nbsp; <em>y</em>1.2sin(<em>x</em> )  cos(2.4<em>x</em>) for <em>x</em> [ 2,2].

The training set is generated by dividing the domain [-2, 2] using a uniform step length 0.05, while the test set is constructed by dividing the domain [-2, 2] using a uniform step length 0.01. You may use the MATLAB neural network toolbox to implement a MLP (see the Appendix for guidance) and do the following experiments:

a). Use the sequential mode with BP algorithm and experiment with the following different structures of the MLP: 1-n-1 (where n = 1, 2, …, 10, 20, 50, 100). For each architecture plot out the outputs of the MLP for the test samples after training and compare them to the desired outputs. Try to determine whether it is under-fitting, proper fitting or over-fitting. Identify the minimal number of hidden neurons from the experiments, and check if the result is consistent with the guideline given in the lecture slides. Compute the outputs of the MLP when x=-3 and +3, and see if the MLP can make reasonable predictions outside of the domain of the input limited by the training set.

b). Use the batch mode with trainlm algorithm to repeat the above procedure.

c). Use the batch mode with trainbr algorithm to repeat the above procedure.

<strong>&nbsp;</strong>

<h1>Q3. Facial Attribute Recognition</h1>
Multi-layer perceptron (MLP) can be used to solve real-world pattern recognition problems. In this assignment, MLP will be designed to handle a binary classification task. Specifically, students are divided into 3 groups based on matric numbers and each group is assigned with different tasks as illustrated in the following Table.

<table width="568">
<tbody>
<tr>
<td width="91"><strong>Group ID </strong></td>
<td width="210"><strong>Task </strong></td>
<td width="267"><strong>Example </strong></td>
</tr>
<tr>
<td width="91">1</td>
<td width="210">Gender Classification</td>
<td width="267">&nbsp;

Male [1]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Female [0]
</td>
</tr>
<tr>
<td width="91">2</td>
<td width="210">Smile Face Detection</td>
<td width="267">&nbsp;

Smile [1]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Non-Smile [0]
</td>
</tr>
<tr>
<td width="91">3</td>
<td width="210">Glasses Wearing Detection</td>
<td width="267">&nbsp;

Glass [1]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Non-Glass [0]
</td>
</tr>
</tbody>
</table>
You may download the zipped dataset (<strong>Face Database.zip</strong>) from IVLE. After unzipping, you will find two folders: <em>TrainImages</em> and <em>TestImages</em> that hold the training set and test set respectively. As demonstrated in the above Table, the training/test data are 1,000/250 RGB images of human faces; and the ground-truth labels associated with each image are given in the <em>.att</em> file that shares the same filename with corresponding image. It is noted that there are 3 binary labels in each <em>.att</em> file as shown below, but <u>you only need one of them according to your assigned</u> <u>group</u>.

——————————————————–

1 &nbsp;&nbsp;&nbsp; | &nbsp;&nbsp;&nbsp;&nbsp; male[1]/female[0] &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for group 1

0 &nbsp;&nbsp;&nbsp; | &nbsp;&nbsp;&nbsp;&nbsp; smile[1]/non-smile[0] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for group 2

0 &nbsp;&nbsp;&nbsp; | &nbsp;&nbsp;&nbsp;&nbsp; glass[1]/non-glass[0]&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for group 3

——————————————————–

In order to find your group, you need to calculate ‘<strong>mod(LTD, 3) + 1</strong>’ where <em>LTD</em> is the last two digits of your matric number, e.g. A1234567X is assigned to group mod(67, 3) + 1 = <strong>2</strong> (Smile Face Detection).

All the images are provided in JEPG format with size 101*101. You can use <strong>I = imread(</strong><em>filename</em><strong>)</strong> to read these image files, where <em>filename</em> specifies the relative path to an image (for code efficiency, you may use function <strong>dir()</strong> to get filenames of all the images within a folder). The returned value <strong>I</strong> is an array (101-by-101-by-3 in this assignment) containing the image data. For example,

I = imread(‘TrainImages/Abba_Eban_0001.jpg’);

will read image ‘Abba_Eban_0001.jpg’ from the training set into MATLAB workspace. For simplicity, <u>grayscale images are used in this assignment</u>, and you can convert the RGB image into grayscale image by function <strong>rgb2gray()</strong>: G = rgb2gray(I);

Then, you could get the grayscale image as a 101-by-101 array which can be displayed using <strong>imshow()</strong>. In order to efficiently process all the image data, you may need to rearrange the matrix form data <strong>G</strong> into a vector by

V = G(:);

and the resulting <strong>V</strong> is a column vector whose elements are taken column-wisely from <strong>G</strong>. Subsequently, you could group all the training images together using

train_images = [V1, V2, …];

and group all the test images together following the same way. In the next, these matrices (101*101-by-image_number) are used as input to the networks.

As mentioned before, the ground-truth labels are stored in the <em>.att</em> file associated with each image and can be extracted by

L = load(‘TrainImages/Abba_Eban_0001.att’); l = L(i);

where <strong>i</strong> is your group ID and <strong>l</strong> is a binary number holding the ground-truth label of image ‘Abba_Eban_0001.jpg’ for your assigned task.

You are required to complete the following tasks:

<ol>
<li>a) For your assigned task, plot and analyse the label distribution of both the training set and test set.</li>
</ol>
<strong>&nbsp;</strong>b) Apply Rosenblatt’s perceptron (single layer perceptron) to your assigned task. After the training procedure, calculate the classification accuracy for both the training set and test set, and evaluate the performance of the perceptron.

<strong>&nbsp;</strong>c) The original input dimension is 10,201 (101*101), which may be redundant and leave space for reduction. Try to naively downsample the images or apply a more sophisticated technique like PCA to these images. Then, retrain the perceptron in b) with the dimensionally reduced images and compare the results. (you may use imresize() and pca() in this task)

<ol>
<li>d) Apply MLP to your assigned task using batch mode training. After the training procedure, calculate the classification accuracy for both the training set and test set, and evaluate the performance of the network.</li>
</ol>
<strong>&nbsp; </strong>e)Apply MLP to your assigned task using sequential mode training. After the training procedure, calculate the classification accuracy for both the training set and test set, and evaluate the performance of the network. Compare the result with that of d) and make your recommendation on these two approaches.

<strong>) </strong>f) You may notice that all the images, either for training or test, are already aligned by placing eyes at a certain location. Do you think it is necessary to do so? Justify your answer.

<strong>Important note</strong>: There are many design and training issues to be considered when you apply neural networks to solve real world problems. We have discussed most of them in the lecture four. Some of them have clear answers, some of them may rely on empirical rules, and some of them have to be determined by trial and error. I believe that you will have more fun playing with these design parameters and making your own judgment rather than solving the problem with a prescribed set of parameters. Hence, there is no standard answer to this problem, and the marking will be based upon the whole procedure rather than the final classification accuracy. (Use “help” and “doc” commands in MATLAB to get familiar with the functions that you don’t know and Google everything that confuse you.)

<h1>Appendix</h1>
<ol>
<li>Create a feed-forward back propagation network using MATLAB toolbox using: net = patternnet(hiddenSizes, trainFcn, performFcn)</li>
</ol>
where the arguments are specified as follows:

hiddenSizes — Row vector of one or more hidden layer sizes (default = 10);&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trainFcn — Training function (default = ‘trainscg’);&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; performFcn — Performance function (default = ‘crossentropy’).

<strong>trainFcn</strong> specifies the optimization algorithm based on which the network is updated during training, and there are many choices:

&nbsp;
